function [xy,ie] = Snake(img, anchors, varargin)%SNAKE  - active contour tracker)%%	usage:  [xy,e] = Snake(img, anchors, ...)%% given intensity (0:255) image and [nAnchors x X,Y] anchors% returns [nPoints x X,Y] contour best fit to image forces%% optionally returns image energy IE%% additional supported 'NAME',VALUE parameters (defaults in {}):%   ALPHA   - penalizes changes in distances between points (elasticity); {1}%   BETA    - penalizes oscillations in the contour (curvature); {1}%   GAMMA   - image energy weight; {1}%   DELTA   - step size; {1}%   SIGMA   - image filter weight; {10}%   NPOINTS - number of output points; {100}%   MAXITER - max iterations; {100}%   TRACK   - 'W' attracted to white edges, 'B' attracted to black; {'W'}%% any of these parameters may also be specified by defining a variable called SnakeParams% in the base workspace; e.g. SnakeParams = {'ALPHA',.5,'SIGMA',3}%% this is a reworking of the FBOAC algorithm of Shemesh and Ben-Shahar that constrains snake endpoints% to lie on an arbitrary boundary; here this is a line orthongonal to the last two anchor points % at each end of the snake% modified version of code available from https://www.cs.bgu.ac.il/~icvl/icvl_projects/free-boundary-conditions-active-contours/% Copyrights 2011: Yael Gabay, Liat Cohen, Michal Shemesh and Ohad Ben-Shahar% mkt 12/15, revised 08/16if nargin < 2, eval('help Snake'); return; end;% snake defaultsalpha = 1;beta = 0;gamma = 1;delta = 1;sigma = 10;nPoints = 100;maxIters = 100;track = 0;			% (Handles.NEG); 1: attracted to black, 0: attracted to white% load parameters from SNAKEPARAMS if defined in the base workspaceparams = [evalin('base','SnakeParams','{}') , varargin];if mod(length(params),2),	error('Snake specification error:  parameters must be specified in ''NAME'',VALUE format');end;for ai = 2 : 2 : length(params),	switch upper(params{ai-1}),		case 'ALPHA', alpha = params{ai};		case 'BETA', beta = params{ai};		case 'GAMMA', gamma = params{ai};		case 'DELTA', delta = params{ai};		case 'SIGMA', sigma = params{ai};		case 'NPOINTS', nPoints = params{ai};		case 'MAXITER', maxIters = params{ai};		case 'TRACK', track = (upper(params{ai}(1)) == 'B');		otherwise, error('unrecognized parameter (%s)', params{ai-1});	end;end;%----- apply snakecondAI = [];stopThreshold = .0001;resamplingDist = 1;handles.Image = im2double(img);handles.AC = anchors';		% [X,Y x nPoints]handles.ACType = 'open';handles.Smooth_Image = 1;handles.Sigma = sigma;[handles.Rows,handles.Cols,~] = size(img);timePerFrame = 1/15;transversality = 0;handles.NEG = track;			% 1: attracted to black, 0: attracted to white% derive BC1,2 as lines orthogonal to last anchor segmentshandles.BC1Sampled = GetOrthogonalLine(anchors(1:2,:));handles.BC2Sampled = GetOrthogonalLine(anchors([end,end-1],:));% implot(img); hold on; p2(anchors,'b-o');% p2(handles.BC1Sampled','r-+');% p2(handles.BC2Sampled','r-+'); [handles.Energy, handles.gradEnergyX, handles.gradEnergyY]=Calc_Image_Energy(handles, handles.Image);start = tic;for i = 1 : maxIters,    %% -------------------------------------------    resample    [handles.AC, resamplingFixedDist] = curveResample(handles.AC,handles.ACType, resamplingDist);    %   check if there are less then 6 points in an open curve    %   or less then 2 points in a closed curve    if ( (size(handles.AC,2)<6 && strcmp(handles.ACType, 'open')) || (size(handles.AC,2)<2))        i = i-1;        break;    end            %% -------------------------------------------     compute the next step    [handles.AC, condAI] = computeNextCurve(condAI, handles, alpha, beta, gamma, 1/delta, transversality, resamplingFixedDist);    ACs{i+1, 1} = handles.AC;    ACsEnergy{i+1, 1} = getCurveEnrg(handles.ACType, handles.AC,handles.Energy, alpha, beta, gamma);    %   Stopping criterion check - early convergence    if ( (i>1) && (abs( sum(ACsEnergy{i+1,1})-sum(ACsEnergy{i,1}) ) <= stopThreshold) )%fprintf('converged\n');        break;    end        %   Stopping criterion check - time per frame%     if ( toc(start) >=  timePerFrame )% fprintf('timeout\n');%         break;%     endend% p2(handles.AC','g');% % implot(handles.Energy); hold on; % p2(handles.BC1Sampled','r-+'); % p2(handles.BC2Sampled','r-+');% p2(handles.AC','g')xy = handles.AC';k = [0 ; cumsum(sqrt(sum(diff(xy).^2,2)))];xy = interp1(k,xy,linspace(0,k(end),nPoints));ie = handles.Energy;%% ----- supportfunction energy = getCurveEnrg(ACType, AC,Energy, alpha, beta, gamma)if (size(AC,2)<2)    energy = [0 0 0];else    %% Compute derivatives:%    i=sqrt(-1);    Dists=abs(diff(AC(1,:)+AC(2,:)*i));    Dists(end+1) = dist(AC(:,1)', AC(:,end));    DistsM1=[Dists(end) Dists(1,1:end-1)];    % M for Minus, P for Plus    x0=AC(1,:);    xM1=[x0(end) x0(1,1:end-1)];    xP1=[x0(1,2:end) x0(1)];    y0=AC(2,:);    yM1=[y0(end) y0(1,1:end-1)];    yP1=[y0(1,2:end) y0(1)];    %% compute intE1 - 1st deriv: based on a central differences using taylor serios    %                        intE2 - 2nd deriv: with error of O(h)     x1deriv = -(Dists./(DistsM1.*(DistsM1+Dists))).*xM1 + ((Dists-DistsM1)./(Dists.*DistsM1)).*x0 + (DistsM1./(Dists.*(DistsM1+Dists))).*xP1;     y1deriv = -(Dists./(DistsM1.*(DistsM1+Dists))).*yM1 + ((Dists-DistsM1)./(Dists.*DistsM1)).*y0 + (DistsM1./(Dists.*(DistsM1+Dists))).*yP1;     x2deriv = (2./(DistsM1.*(Dists+DistsM1))).*xM1 + (-2./(Dists.*DistsM1)).*x0 + (2./(Dists.*(Dists+DistsM1))).*xP1;     y2deriv = (2./(DistsM1.*(Dists+DistsM1))).*yM1 + (-2./(Dists.*DistsM1)).*y0 + (2./(Dists.*(Dists+DistsM1))).*yP1;%     if (strcmp(ACType, 'open'))         %% fixing end points derivatives         % Manualy compute AC ends derivatives         x1deriv(1) = x0(1) * ( -(2*Dists(1)+Dists(2)) / (Dists(1)*(Dists(1)+Dists(2))) ) + ...                                    x0(2) * ( (Dists(1)+Dists(2)) / (Dists(1)*Dists(2))  ) + ...                                    x0(3) * ( -Dists(1) / (Dists(2)*(Dists(1)+Dists(2))) );         y1deriv(1) = y0(1) * ( -(2*Dists(1)+Dists(2)) / (Dists(1)*(Dists(1)+Dists(2))) ) + ...                                    y0(2) *  ( (Dists(1)+Dists(2)) / (Dists(1)*Dists(2)) )+ ...                                    y0(3) * ( -Dists(1) / (Dists(2)*(Dists(1)+Dists(2))) );             %using lagrange polynom to calc forward and backward differences:         x2deriv(1) = x0(1) * ( (2*(3*Dists(1)+2*Dists(2)+Dists(3))) / (Dists(1)*(Dists(1)+Dists(2))*(Dists(1)+Dists(2)+Dists(3))) ) + ...                                    x0(2) * ( (-2*(2*Dists(1)+2*Dists(2)+Dists(3))) / (Dists(1)*Dists(2)*(Dists(2)+Dists(3))) ) + ...                                    x0(3) * ( (2*(2*Dists(1)+Dists(2)+Dists(3))) / ((Dists(1)+Dists(2))*Dists(2)*Dists(3)) ) + ...                                    x0(4) * ( (-2*(2*Dists(1)+Dists(2))) / ((Dists(1)+Dists(2)+Dists(3))*(Dists(2)+Dists(3))*Dists(3)) );         y2deriv(1) = y0(1) * ( (2*(3*Dists(1)+2*Dists(2)+Dists(3))) / (Dists(1)*(Dists(1)+Dists(2))*(Dists(1)+Dists(2)+Dists(3))) ) + ...                                    y0(2) * ( (-2*(2*Dists(1)+2*Dists(2)+Dists(3))) / (Dists(1)*Dists(2)*(Dists(2)+Dists(3))) ) + ...                                    y0(3) * ( (2*(2*Dists(1)+Dists(2)+Dists(3))) / ((Dists(1)+Dists(2))*Dists(2)*Dists(3)) ) + ...                                    y0(4) * ( (-2*(2*Dists(1)+Dists(2))) / ((Dists(1)+Dists(2)+Dists(3))*(Dists(2)+Dists(3))*Dists(3)) );             Dists(end) = 0;%     end     C1derivSqr = x1deriv.^2+y1deriv.^2;     intE1 = alpha*sum(C1derivSqr.*Dists);     C2derivSqr = x2deriv.^2+y2deriv.^2;     intE2 = beta*sum(C2derivSqr.*Dists) ;     imageEnergyOnCurve = interp2(Energy, x0, y0, 'linear');     extE = gamma*sum(imageEnergyOnCurve.*Dists) ;     energy = [intE1 intE2  extE];endfunction [newPoints, resamplingDist] = curveResample(points, ACType, resamplingDist)length = 0;dist=zeros(1);intervals=zeros(1);i=1;while (i<size(points, 2))    dist(i) = norm(points(1:2, i) - points(1:2, i+1),2);    if (dist(i)~=0)        length = length + dist(i);        intervals(i+1) = length;        i=i+1;    else        points(:, i+1)=[];    endendif (size(points,2)~=1)    intervals = intervals/length;    %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%    numOfPoints = ceil(length/resamplingDist) + 1;    resamplingDist = length/(numOfPoints-1);    %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%    newPoints = interp1( intervals , points', 0:resamplingDist/length:1,'linear')';else    newPoints=points;endfunction [ newAC, condAI ] = computeNextCurve(condAI, handles, alpha, beta, gamma, delta_1, transversality, equalDist)%% Arguments:% pass CONDAI as input/output variable rather than global%     * handles - image parameters.%     * alpha - Controls the elasticity of the snake.%     * betha - Controls curvature.%     * delta - Controls the step size.%   transversality, equalDist - boolean values% Output:new AC points after one stage of evolution.% Get parameters of the ACx = handles.AC(1,:);y = handles.AC(2,:);n = size(handles.AC, 2);    % Interpolate to find the image energy on the discrete grid[gradEnergyX gradEnergyY] = getCurveGradEnrg(x,y,handles.gradEnergyX, handles.gradEnergyY);% compute matrix A, check whether the distance between point is equal or unequalif (equalDist)    A = constructCoeffMatA_equalDist(handles.ACType, n, equalDist , alpha, beta);else    A = constructCoeffMatA_unequalDist(handles.ACType, handles.AC, alpha, beta);end% compute AC new positionAI=A + (delta_1)*eye(n);if isempty(condAI), condAI = cond(AI); endif (condAI<10^15)        [L U]=lu(AI);        x=U\(L\((delta_1)*x -gamma*gradEnergyX)');        y=U\(L\((delta_1)*y -gamma*gradEnergyY)');else        x=gmres(AI,((delta_1)*x-gamma*gradEnergyX)',10,0.0001,n,[],[],x');        y=gmres(AI,((delta_1)*y-gamma*gradEnergyY)',10,0.0001,n,[],[],y');end newAC(1,:)= x';newAC(2,:)= y';%check if AC is open or close. if open, need to check BC existence (size(BC) ~= 0)%if (strcmp(handles.ACType,'open'))%     if (transversality)%         if (size(handles.BC1Points,1)~=0)%             newAC(:,1)=minDistPointOnCurve(newAC(:,2), handles.BC1Sampled);%         end%         if (size(handles.BC2Points,1)~=0)%             newAC(:,n)=minDistPointOnCurve(newAC(:,n-1), handles.BC2Sampled);%         end%    else%        if (size(handles.BC1Points,1)~=0)            newAC(:,1)=minDistPointOnCurve(newAC(:,1), handles.BC1Sampled);%         end%         if (size(handles.BC2Points,1)~=0)            newAC(:,n)=minDistPointOnCurve(newAC(:,n), handles.BC2Sampled);%        end%   end%endx = newAC(1,:)';y = newAC(2,:)';% Checking to see if there are interpolation points% outside of imagetempArr=find(x<1);newAC(1,tempArr)=1;tempArr=find(y<1);newAC(2,tempArr)=1;tempArr=find(x>handles.Cols);newAC(1,tempArr)=handles.Cols;tempArr=find(y>handles.Rows);newAC(2,tempArr)=handles.Rows;%clear tempArr;function [gradEnergyX gradEnergyY] = getCurveGradEnrg(x,y,gradEngX,gradEngY)gradEnergyX = interp2(gradEngX, x, y, 'linear');gradEnergyY = interp2(gradEngY, x, y, 'linear');%% minDistPointOnCurve%                                    detects the nearest to 'point' point from curvePoints:%                                    if curvePoints contains only 2 points (it means it is a%                                    vertical/horizontal curve) we return the closest point on the line%                                    connecting them%                                   % Arguments:        * point - of the form [ x  y ]%                                                                     % Output:                newPoint - of the form [ x ; y ]%                                                           the nearest to 'point' point from curvePoints%%function newPoint = minDistPointOnCurve(point, curvePoints)if (size(curvePoints, 2)==2 && curvePoints(1,1)==curvePoints(1,2) &&...        ((curvePoints(2,1)<=point(2)<=curvePoints(2,2)) || ((curvePoints(2,1)>=point(2)>=curvePoints(2,2)))))         %   vertical line    newPoint = [curvePoints(1,1), point(2)];else if (size(curvePoints, 2)==2 && curvePoints(2,1)==curvePoints(2,2)&&...                    ((curvePoints(1,1)<=point(1)<=curvePoints(1,2)) || ((curvePoints(1,1)>=point(1)>=curvePoints(1,2)))))         %   horizontal line        newPoint = [point(1), curvePoints(2,1)];    else    %   general line        distances = dist(point' , curvePoints);        min_dist = min(distances);        ind = find(distances == min_dist);        newPoint = curvePoints( :, ind(1));    endendfunction [A] = constructCoeffMatA_equalDist(ACType, n, h, alpha, beta)if (n<6 && strcmp(ACType, 'open'))    error('number of points is maller than 6 - cannot estimate derivatives');endA = -2*alpha*deriv2Mat( h, n, ACType) + 2*beta*deriv4Mat( h, n, ACType);%% constract second derivative matrixfunction M = deriv2Mat( h, n , type)On = ones(1,n);% M for Minus, P for Plus:cM1 = (1/h^2)*On;c0 = -2*(1/h^2)*On;cP1 = cM1;Aux = [cP1' cM1' c0' cP1' cM1'];M = full(spdiags(Aux, [-(n-1) -1 0 1 (n-1)], n, n));%if (strcmp(type, 'open'))    %   estimating the second derivative at the ends    %   using forward and backward differences.    M(1,:) = [ 2 -5 4 -1 zeros(1,n-4) ]*(1/h^2);    M(n,:) = fliplr(M(1,:));%end%% constract fourth derivative matrixfunction M = deriv4Mat( h, n, type)On = ones(1,n);% M for Minus, P for Plus:cM2 = (1/h^4)*On;cM1 = -4*(1/h^4)*On;c0 = 6*(1/h^4)*On;cP1 = cM1;cP2 = cM2;Aux = [cP1' cP2' cM2' cM1' c0' cP1' cP2' cM2' cM1'];M = full(spdiags(Aux, [-(n-1) -(n-2) -2 -1 0 1 2 (n-2) (n-1)], n, n));%if (strcmp(type, 'open'))    %   estimating the forth derivative  at the ends    %   using forward and backward differences.    M(1,:) = [ 3 -14 26 -24 11 -2 zeros(1,n-6) ]*(1/h^4);    M(2,:) = [ 2 -9 16 -14 6 -1 zeros(1,n-6) ]*(1/h^4);    M(n-1,:) = fliplr(M(2,:));    M(n,:) = fliplr(M(1,:));%end%% Calc_Image_Energy%                                    loads Energy Image%                                   % Arguments:        * handles - gui's handles object%                                                                     % Output:               handles - the updated gui's handles object%%function [Energy, gradEnergyX, gradEnergyY]= Calc_Image_Energy(handles, Image)%%  smooth image if needed:%if (get(handles.Smooth_Image,'Value')==1)           % If smooth image is checkedif handles.Smooth_Image==1           % If smooth image is checked%    sigma=str2double(get(handles.Sigma_val,'String'));      % read sigma value    sigma=handles.Sigma;      % read sigma value    fSize = [ceil(3*sigma) ceil(3*sigma)];          gf = fspecial('gaussian', fSize, sigma);        % Build Gauss filter%    gaussImg = rgb2gray(double(imfilter(Image, gf, 'replicate')));      % Apply Gauss filter to image    gaussImg = imfilter(Image, gf, 'replicate');      % Apply Gauss filter to imageelse    gaussImg = Image;end%% calculate energy according to selection by user[Ix, Iy]=getImgGradients(gaussImg);        % Find gradients of gray-scale image%if (get(handles.Minus_Image_Grad, 'Value')==1 || get(handles.Plus_Image_Grad, 'Value')==1)      %energy depends on image gradient    enrgImg = sqrt(Ix.^2 + Iy.^2);%else    % energy type selected is +/- Img%    enrgImg=gaussImg;%end%% normalize energy between 0 and 1enrgImg=imnorm(enrgImg);%% set energy%if (get(handles.Minus_Image_Grad,'Value')==1 || get(handles.Minus_Image,'Value')==1)%     enrgImg = 1 - enrgImg;%endif handles.NEG, enrgImg = 1 - enrgImg; end;Energy = enrgImg;%% Store image energy gradients[gradEnergyX, gradEnergyY]=getImgGradients(Energy);%% normalize energy gradients between -1 and 1m=max(max(abs(gradEnergyX)));if(m>0)    gradEnergyX=gradEnergyX/m;endm=max(max(abs(gradEnergyY)));if(m>0)    gradEnergyY=gradEnergyY/m;end%% Calc image (or energy image) gradientsfunction[gradX, gradY]=getImgGradients(Img)fy = -fspecial('sobel');fx = fy';gradY = imfilter(Img, fy, 'replicate');gradX = imfilter(Img, fx, 'replicate');%% normalize enrgImg between 0 to 1function[enrgImg]=imnorm(enrgImg)    maxEnrgImg = max(enrgImg(:));    minEnrgImg = min(enrgImg(:));    dif=maxEnrgImg - minEnrgImg;    if (dif>0.0001)        enrgImg = (enrgImg - minEnrgImg)/(dif) ;    else if (maxEnrgImg~=0)        enrgImg=enrgImg/maxEnrgImg;        end    end%% get end constraints as line orthogonal to last two anchor pointsfunction BC = GetOrthogonalLine(p)p0 = p(1,:);p1 = p(2,:) - p0;[th,r] = cart2pol(p1(1),p1(2));r = 2;[x,y] = pol2cart([-1;1]*pi/2+th,[r;r]);BC = [x,y] + [1;1]*p0;BC = BC';		% [X,Y x nPoints]